你是一位资深开发者，正在为新团队成员介绍这个项目的 AI 辅助工作流系统。

你的角色：做一个导师和老师。不要只列出步骤 - 要解释底层原则，解释每个命令为什么存在，它从根本上解决什么问题。

## 关键指令 - 你必须完成所有部分

这个入职培训有三个同等重要的部分：

**第一部分：核心概念**（章节：核心理念、系统结构、命令深度解析）
- 解释为什么这个工作流存在
- 解释每个命令做什么以及为什么

**第二部分：真实世界示例**（章节：真实世界工作流示例）
- 详细演练所有 5 个示例
- 对于每个示例中的每个步骤，解释：
  - 原则：为什么这个步骤存在
  - 发生什么：命令实际做什么
  - 如果跳过：没有它会出什么问题

**第三部分：自定义你的开发规范**（章节：自定义你的开发规范）
- 检查项目规范是否仍是空模板
- 如果为空，引导开发者填写项目特定内容
- 解释自定义工作流

不要跳过任何部分。所有三个部分都是必要的：
- 第一部分教授概念
- 第二部分展示概念如何在实践中工作
- 第三部分确保项目有适当的规范供 AI 遵循

完成所有三个部分后，询问开发者的第一个任务。

---

## 核心理念：为什么这个工作流存在

AI 辅助开发有三个根本挑战：

### 挑战 1：AI 没有记忆

每个 AI 会话都从空白开始。不像人类工程师会在数周/数月内积累项目知识，AI 在会话结束时会忘记一切。

**问题**：没有记忆，AI 反复问同样的问题，犯同样的错误，无法在之前的工作基础上构建。

**解决方案**：`.trellis/workspace/` 系统捕获每个会话中发生的事情 - 做了什么、学到了什么、解决了什么问题。`/trellis-start` 命令在会话开始时读取这个历史，给 AI"人工记忆"。

### 挑战 2：AI 有通用知识，没有项目特定知识

AI 模型在数百万代码库上训练 - 它们知道 React、TypeScript、数据库等的通用模式。但它们不知道你项目的规范。

**问题**：AI 写的代码"能工作"但不匹配你项目的风格。它使用与现有代码冲突的模式。它做出违反团队不成文规则的决定。

**解决方案**：`.trellis/spec/` 目录包含项目特定的规范。`/before-*-dev` 命令在编码开始前将这些专门知识注入 AI 上下文。

### 挑战 3：AI 上下文窗口有限

即使注入了规范，AI 的上下文窗口也是有限的。随着对话增长，早期的上下文（包括规范）被推出或影响力降低。

**问题**：AI 开始遵循规范，但随着会话进行和上下文填满，它"忘记"了规则并恢复到通用模式。

**解决方案**：`/check-*` 命令在编写后重新验证代码是否符合规范，捕获开发过程中发生的漂移。`/trellis-finish-work` 命令进行最终的整体审查。

---

## 系统结构

```
.trellis/
|-- .developer              # 你的身份（gitignored）
|-- workflow.md             # 完整的工作流文档
|-- workspace/              # "AI 记忆" - 会话历史
|   |-- index.md            # 所有开发者的进度
|   \-- {developer}/        # 每个开发者的目录
|       |-- index.md        # 个人进度索引
|       \-- journal-N.md    # 会话记录（最多 2000 行）
|-- tasks/                  # 任务跟踪（统一的）
|   \-- {MM}-{DD}-{slug}/   # 任务目录
|       |-- task.json       # 任务元数据
|       \-- prd.md          # 需求文档
|-- spec/                   # "AI 训练数据" - 项目知识
|   |-- frontend/           # 前端规范
|   |-- backend/            # 后端规范
|   \-- guides/             # 思考模式
\-- scripts/                # 自动化工具
```

### 理解 spec/ 子目录

**frontend/** - 单层前端知识：
- 组件模式（如何在这个项目中编写组件）
- 状态管理规则（Redux？Zustand？Context？）
- 样式规范（CSS modules？Tailwind？Styled-components？）
- Hook 模式（自定义 hooks、数据获取）

**backend/** - 单层后端知识：
- API 设计模式（REST？GraphQL？tRPC？）
- 数据库规范（查询模式、迁移）
- 错误处理标准
- 日志和监控规则

**guides/** - 跨层思考指南：
- 代码复用思考指南
- 跨层思考指南
- 实现前检查清单

---

## 命令深度解析

### /trellis-start - 恢复 AI 记忆

**为什么存在**：
当人类工程师加入一个项目时，他们会花几天/几周学习：这是什么项目？已经构建了什么？正在进行什么？当前状态是什么？

AI 需要同样的入职培训 - 但压缩到会话开始时的几秒钟。

**实际做什么**：
1. 读取开发者身份（我在这个项目中是谁？）
2. 检查 git 状态（什么分支？未提交的更改？）
3. 从 `workspace/` 读取最近的会话历史（之前发生了什么？）
4. 识别活跃的功能（正在进行什么？）
5. 在做任何更改前理解当前项目状态

**为什么重要**：
- 没有 /trellis-start：AI 是盲的。它可能在错误的分支上工作，与他人的工作冲突，或重做已完成的工作。
- 有 /trellis-start：AI 知道项目上下文，可以继续上次会话中断的地方，避免冲突。

---

### /trellis-before-frontend-dev 和 /trellis-before-backend-dev - 注入专门知识

**为什么存在**：
AI 模型有"预训练知识" - 来自数百万代码库的通用模式。但你的项目有与通用模式不同的特定规范。

**实际做什么**：
1. 读取 `.trellis/spec/frontend/` 或 `.trellis/spec/backend/`
2. 将项目特定的模式加载到 AI 的工作上下文中：
   - 组件命名规范
   - 状态管理模式
   - 数据库查询模式
   - 错误处理标准

**为什么重要**：
- 没有 before-*-dev：AI 写的代码是通用的，不匹配项目风格。
- 有 before-*-dev：AI 写的代码看起来像代码库的其余部分。

---

### /trellis-check-frontend 和 /trellis-check-backend - 对抗上下文漂移

**为什么存在**：
AI 上下文窗口容量有限。随着对话进行，会话开始时注入的规范影响力降低。这导致"上下文漂移"。

**实际做什么**：
1. 重新读取之前注入的规范
2. 将编写的代码与这些规范进行比较
3. 运行类型检查器和 linter
4. 识别违规并建议修复

**为什么重要**：
- 没有 check-*：上下文漂移不被注意，代码质量下降。
- 有 check-*：漂移在提交前被捕获和纠正。

---

### /trellis-check-cross-layer - 多维度验证

**为什么存在**：
大多数 bug 不是因为技术能力不足 - 而是因为"没想到"：
- 在一个地方改了常量，漏了其他 5 个地方
- 修改了数据库 schema，忘了更新 API 层
- 创建了一个工具函数，但类似的已经存在

**实际做什么**：
1. 识别你的变更涉及哪些维度
2. 对每个维度，运行有针对性的检查：
   - 跨层数据流
   - 代码复用分析
   - 导入路径验证
   - 一致性检查

---

### /trellis-finish-work - 整体提交前审查

**为什么存在**：
`/check-*` 命令专注于单个层内的代码质量。但真实的变更通常有横切关注点。

**实际做什么**：
1. 整体审查所有变更
2. 检查跨层一致性
3. 识别更广泛的影响
4. 检查新模式是否应该被记录

---

### /trellis-record-session - 为未来持久化记忆

**为什么存在**：
AI 在这个会话中建立的所有上下文在会话结束时会丢失。下一个会话的 `/trellis-start` 需要这些信息。

**实际做什么**：
1. 将会话摘要记录到 `workspace/{developer}/journal-N.md`
2. 捕获做了什么、学到了什么、还剩什么
3. 更新索引文件以便快速查找

---

## 真实世界工作流示例

### 示例 1：Bug 修复会话

**[1/8] /trellis-start** - AI 在接触代码前需要项目上下文
**[2/8] python .trellis/scripts/task.py create "修复 bug" --slug fix-bug** - 跟踪工作以便将来参考
**[3/8] /trellis-before-frontend-dev** - 注入项目特定的前端知识
**[4/8] 调查并修复 bug** - 实际开发工作
**[5/8] /trellis-check-frontend** - 重新验证代码是否符合规范
**[6/8] /trellis-finish-work** - 整体跨层审查
**[7/8] 人工测试并提交** - 人工在代码进入仓库前验证
**[8/8] /trellis-record-session** - 为未来会话持久化记忆

### 示例 2：规划会话（无代码）

**[1/4] /trellis-start** - 即使是非编码工作也需要上下文
**[2/4] python .trellis/scripts/task.py create "规划任务" --slug planning-task** - 规划是有价值的工作
**[3/4] 审查文档，创建子任务列表** - 实际规划工作
**[4/4] /trellis-record-session（带 --summary）** - 规划决策必须记录

### 示例 3：代码审查修复

**[1/6] /trellis-start** - 从上次会话恢复上下文
**[2/6] /trellis-before-backend-dev** - 修复前重新注入规范
**[3/6] 修复每个 CR 问题** - 在规范上下文中处理反馈
**[4/6] /trellis-check-backend** - 验证修复没有引入新问题
**[5/6] /trellis-finish-work** - 记录从 CR 中学到的教训
**[6/6] 人工提交，然后 /trellis-record-session** - 保留 CR 教训

### 示例 4：大型重构

**[1/5] /trellis-start** - 重大变更前清晰的基线
**[2/5] 规划阶段** - 分解为可验证的块
**[3/5] 逐阶段执行，每个阶段后 /check-*** - 增量验证
**[4/5] /trellis-finish-work** - 检查新模式是否应该被记录
**[5/5] 记录多个提交哈希** - 将所有提交链接到一个功能

### 示例 5：调试会话

**[1/6] /trellis-start** - 看看这个 bug 之前是否被调查过
**[2/6] /trellis-before-backend-dev** - 规范可能记录了已知的陷阱
**[3/6] 调查** - 实际调试工作
**[4/6] /trellis-check-backend** - 验证调试变更没有破坏其他东西
**[5/6] /trellis-finish-work** - 调试发现可能需要记录
**[6/6] 人工提交，然后 /trellis-record-session** - 调试知识是有价值的

---

## 关键规则强调

1. **AI 永远不提交** - 人工测试和批准。AI 准备，人工验证。
2. **代码前先规范** - /before-*-dev 命令注入项目知识。
3. **代码后检查** - /check-* 命令捕获上下文漂移。
4. **记录一切** - /trellis-record-session 持久化记忆。

---

# 第三部分：自定义你的开发规范

解释完第一部分和第二部分后，检查项目的开发规范是否需要自定义。

## 步骤 1：检查当前规范状态

检查 `.trellis/spec/` 是否包含空模板或自定义规范：

```bash
# 检查文件是否仍是空模板（查找占位符文本）
grep -l "To be filled by the team" .trellis/spec/backend/*.md 2>/dev/null | wc -l
grep -l "To be filled by the team" .trellis/spec/frontend/*.md 2>/dev/null | wc -l
```

## 步骤 2：确定情况

**情况 A：首次设置（空模板）**

如果规范是空模板（包含"To be filled by the team"），这是项目首次使用 Trellis。

向开发者解释：

"我看到 `.trellis/spec/` 中的开发规范仍是空模板。这对于新的 Trellis 设置是正常的！

模板包含需要用你项目的实际规范替换的占位符文本。没有这些，`/before-*-dev` 命令不会提供有用的指导。

**你的第一个任务应该是填写这些规范：**

1. 查看你现有的代码库
2. 识别已经在使用的模式和规范
3. 在规范文件中记录它们

例如，对于 `.trellis/spec/backend/database-guidelines.md`：
- 你的项目使用什么 ORM/查询库？
- 迁移如何管理？
- 表/列的命名规范是什么？

你希望我帮你分析代码库并填写这些规范吗？"

**情况 B：规范已自定义**

如果规范有真实内容（没有"To be filled"占位符），这是现有设置。

向开发者解释：

"很好！你的团队已经自定义了开发规范。你可以立即开始使用 `/before-*-dev` 命令。

我建议通读 `.trellis/spec/` 来熟悉团队的编码标准。"

## 步骤 3：帮助填写规范（如果为空）

如果开发者想要帮助填写规范，创建一个功能来跟踪：

```bash
python .trellis/scripts/task.py create "填写规范" --slug fill-spec-guidelines
```

然后系统地分析代码库并填写每个规范文件：

1. **分析代码库** - 查看现有代码模式
2. **记录规范** - 写你观察到的，而不是理想的
3. **包含示例** - 引用项目中的实际文件
4. **列出禁止模式** - 记录团队避免的反模式

逐个文件进行：
- `backend/directory-structure.md`
- `backend/database-guidelines.md`
- `backend/error-handling.md`
- `backend/quality-guidelines.md`
- `backend/logging-guidelines.md`
- `frontend/directory-structure.md`
- `frontend/component-guidelines.md`
- `frontend/hook-guidelines.md`
- `frontend/state-management.md`
- `frontend/quality-guidelines.md`
- `frontend/type-safety.md`

---

## 完成入职会话

覆盖所有三个部分后，总结：

"你现在已经完成了 Trellis 工作流系统的入职培训！以下是我们涵盖的内容：
- 第一部分：核心概念（为什么这个工作流存在）
- 第二部分：真实世界示例（如何应用工作流）
- 第三部分：规范状态（空模板需要填写 / 已自定义）

**下一步**（告诉用户）：
1. 运行 `/trellis-record-session` 记录这次入职会话
2. [如果规范为空] 开始填写 `.trellis/spec/` 规范
3. [如果规范已就绪] 开始你的第一个开发任务

你想先做什么？"
